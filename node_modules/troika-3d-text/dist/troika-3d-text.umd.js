(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('troika-three-text'), require('troika-3d'), require('three'), require('troika-three-utils')) :
  typeof define === 'function' && define.amd ? define(['exports', 'troika-three-text', 'troika-3d', 'three', 'troika-three-utils'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.troika_3d_text = {}, global.troika_three_text, global.troika_3d, global.THREE, global.troika_three_utils));
}(this, (function (exports, troikaThreeText, troika3d, three, troikaThreeUtils) { 'use strict';

  var tempVec4 = new three.Vector4();

  function getMeshes() {
    var material = troika3d.createDerivedMaterial(
      new three.MeshBasicMaterial({
        transparent: true,
        opacity: 0.3,
        depthWrite: false
      }),
      {
        uniforms: {
          rect: {value: new three.Vector4()},
          depthAndCurveRadius: {value: new three.Vector2()}
        },
        vertexDefs: "\nuniform vec4 rect;\nuniform vec2 depthAndCurveRadius;\n",
        vertexTransform: "\nfloat depth = depthAndCurveRadius.x;\nfloat rad = depthAndCurveRadius.y;\nposition.x = mix(rect.x, rect.z, position.x);\nposition.y = mix(rect.w, rect.y, position.y);\nposition.z = mix(-depth * 0.5, depth * 0.5, position.z);\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * (rad - position.z), rad - cos(angle) * (rad - position.z));\n  // TODO fix normals: normal.xz = vec2(sin(angle), cos(angle));\n}\n"
      }
    );
    var meshes = {
      normal: new three.Mesh(
        new three.BoxBufferGeometry(1, 1, 1).translate(0.5, 0.5, 0.5),
        material
      ),
      curved: new three.Mesh(
        new three.BoxBufferGeometry(1, 1, 1, 32).translate(0.5, 0.5, 0.5),
        material
      )
    };
    return (getMeshes = function () { return meshes; })()
  }


  // TODO make instanceable or a single updated geometry to limit to a single draw call

  var RangeRectFacade = /*@__PURE__*/(function (Instanceable3DFacade) {
    function RangeRectFacade (parent) {
      Instanceable3DFacade.call(this, parent);
      this.depth = 0;
      this.curveRadius = 0;
      this._color = new three.Color();
      this._rect = new three.Vector4();
    }

    if ( Instanceable3DFacade ) RangeRectFacade.__proto__ = Instanceable3DFacade;
    RangeRectFacade.prototype = Object.create( Instanceable3DFacade && Instanceable3DFacade.prototype );
    RangeRectFacade.prototype.constructor = RangeRectFacade;

    RangeRectFacade.prototype.afterUpdate = function afterUpdate () {
      var ref = this;
      var top = ref.top;
      var right = ref.right;
      var bottom = ref.bottom;
      var left = ref.left;
      var color = ref.color;
      var depth = ref.depth;
      var curveRadius = ref.curveRadius;
      this.instancedThreeObject = getMeshes()[curveRadius ? 'curved' : 'normal'];

      if (!this._color.equals(color)) {
        this.setInstanceUniform('diffuse', this._color = new three.Color(color));
      }

      if (!this._rect.equals(tempVec4.set(left, top, right, bottom))) {
        this.setInstanceUniform('rect', tempVec4.clone());
      }
      if (!depth !== this._depth || curveRadius !== this._curveRadius) {
        this.setInstanceUniform('depthAndCurveRadius', new three.Vector2(this._depth = depth, this._curveRadius = curveRadius));
      }
      Instanceable3DFacade.prototype.afterUpdate.call(this);
    };

    RangeRectFacade.prototype.getBoundingSphere = function getBoundingSphere () {
      return null
    };

    return RangeRectFacade;
  }(troika3d.Instanceable3DFacade));

  var THICKNESS = 0.25; //rect depth as percentage of height

  var tempMat4 = new three.Matrix4();
  var tempPlane = new three.Plane();
  var tempVec2 = new three.Vector2();
  var tempVec3 = new three.Vector3();
  var noClip = Object.freeze([-Infinity, -Infinity, Infinity, Infinity]);

  /**
   * Manager facade for selection rects and user selection behavior
   */
  var SelectionManagerFacade = /*@__PURE__*/(function (ListFacade) {
    function SelectionManagerFacade (parent, onSelectionChange) {
      var this$1 = this;

      ListFacade.call(this, parent);
      var textMesh = parent.threeObject;

      this.rangeColor = 0x00ccff;
      this.clipRect = noClip;
      this.curveRadius = 0;

      this.template = {
        key: function (d, i) { return ("rect" + i); },
        facade: RangeRectFacade,
        top: function (d) { return clamp(d.top, this$1.clipRect[1], this$1.clipRect[3]); },
        right: function (d) { return clamp(d.right, this$1.clipRect[0], this$1.clipRect[2]); },
        bottom: function (d) { return clamp(d.bottom, this$1.clipRect[1], this$1.clipRect[3]); },
        left: function (d) { return clamp(d.left, this$1.clipRect[0], this$1.clipRect[2]); },
        depth: function (d) { return (d.top - d.bottom) * THICKNESS; },
        color: function (d) { return this$1.rangeColor; },
        curveRadius: function (d) { return this$1.curveRadius; },
        visible: function (d) {
          var r = this$1.clipRect;
          return d.right > r[0] && d.top > r[1] && d.left < r[2] && d.bottom < r[3]
        },
        renderOrder: function (d) { return this$1.renderOrder || 0; }
      };

      var onDragStart = function (e) {
        var textRenderInfo = textMesh.textRenderInfo;
        if (textRenderInfo) {
          var textPos = textMesh.worldPositionToTextCoords(e.intersection.point, tempVec2);
          var caret = troikaThreeText.getCaretAtPoint(textRenderInfo, textPos.x, textPos.y);
          if (caret) {
            onSelectionChange(caret.charIndex, caret.charIndex);
            parent.addEventListener('drag', onDrag);
            parent.addEventListener('dragend', onDragEnd);
          }
          e.preventDefault();
        }
      };

      var onDrag = function (e) {
        var textRenderInfo = textMesh.textRenderInfo;
        if (e.ray && textRenderInfo) {
          // If it's hitting on the Text mesh, do an exact translation; otherwise raycast to an
          // infinite plane so dragging outside the text bounds will work
          var textPos;
          var ix = e.intersection;
          if (ix && ix.object === textMesh && ix.point) {
            textPos = textMesh.worldPositionToTextCoords(ix.point, tempVec2);
          } else {
            var ray = e.ray.clone().applyMatrix4(troikaThreeUtils.invertMatrix4(textMesh.matrixWorld, tempMat4));
            textPos = ray.intersectPlane(tempPlane.setComponents(0, 0, 1, 0), tempVec3);
          }
          if (textPos) {
            var caret = troikaThreeText.getCaretAtPoint(textRenderInfo, textPos.x, textPos.y);
            if (caret) {
              onSelectionChange(this$1.selectionStart, caret.charIndex);
            }
          }
          e.preventDefault();
        }
      };

      var onDragEnd = function (e) {
        parent.removeEventListener('drag', onDrag);
        parent.removeEventListener('dragend', onDragEnd);
      };

      parent.addEventListener('dragstart', onDragStart);
      parent.addEventListener('mousedown', onDragStart);

      this._cleanupEvents = function () {
        onDragEnd();
        parent.removeEventListener('dragstart', onDragStart);
        parent.removeEventListener('mousedown', onDragStart);
      };
    }

    if ( ListFacade ) SelectionManagerFacade.__proto__ = ListFacade;
    SelectionManagerFacade.prototype = Object.create( ListFacade && ListFacade.prototype );
    SelectionManagerFacade.prototype.constructor = SelectionManagerFacade;

    var prototypeAccessors = { clipRect: { configurable: true } };

    SelectionManagerFacade.prototype.afterUpdate = function afterUpdate () {
      this.data = troikaThreeText.getSelectionRects(this.textRenderInfo, this.selectionStart, this.selectionEnd);
      ListFacade.prototype.afterUpdate.call(this);
    };

    // normalize clipRect
    prototypeAccessors.clipRect.set = function (clipRect) {
      this._clipRect = (clipRect && Array.isArray(clipRect) && clipRect.length === 4) ? clipRect : noClip;
    };
    prototypeAccessors.clipRect.get = function () {
      return this._clipRect
    };

    SelectionManagerFacade.prototype.destructor = function destructor () {
      this._cleanupEvents();
      ListFacade.prototype.destructor.call(this);
    };

    Object.defineProperties( SelectionManagerFacade.prototype, prototypeAccessors );

    return SelectionManagerFacade;
  }(troika3d.ListFacade));

  function clamp(val, min, max) {
    return Math.min(max, Math.max(min, val))
  }

  // Properties that will simply be forwarded to the TextMesh:
  var TEXT_MESH_PROPS = [
    'text',
    'anchorX',
    'anchorY',
    'font',
    'fontSize',
    'letterSpacing',
    'lineHeight',
    'maxWidth',
    'overflowWrap',
    'direction',
    'textAlign',
    'textIndent',
    'whiteSpace',
    'material',
    'color',
    'colorRanges',
    'fillOpacity',
    'outlineOpacity',
    'outlineColor',
    'outlineWidth',
    'outlineOffsetX',
    'outlineOffsetY',
    'outlineBlur',
    'strokeColor',
    'strokeWidth',
    'strokeOpacity',
    'curveRadius',
    'depthOffset',
    'clipRect',
    'orientation',
    'glyphGeometryDetail',
    'sdfGlyphSize',
    'debugSDF'
  ];


  /**
   * Facade wrapper for a TextMesh. All configuration properties of TextMesh
   * are accepted and proxied through directly.
   */
  var Text3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function Text3DFacade(parent) {
      var this$1 = this;

      var mesh = new troikaThreeText.Text();
      mesh.geometry.boundingSphere.version = 0;
      Object3DFacade.call(this, parent, mesh);

      /* TODO mirroring to DOM...?
      const el = this._domEl = document.createElement('section')
      el.style = 'position:fixed;left:-99px;overflow:hidden;width:10px;height:10px;'
      document.body.appendChild(el) //should insert into local element
      */

      this.selectable = false;
      this.selectionStart = this.selectionEnd = -1;
      this.onSyncStart = null;
      this.onSyncComplete = null;

      mesh.addEventListener('syncstart', function (e) {
        this$1.notifyWorld('text3DSyncStart');
        if (this$1.onSyncStart) {
          this$1.onSyncStart();
        }
      });
      mesh.addEventListener('synccomplete', function (e) {
        if (!this$1.isDestroying) {
          mesh.geometry.boundingSphere.version++;
          this$1.afterUpdate();
          this$1.notifyWorld('text3DSyncComplete');
          this$1.requestRender();
          if (this$1.onSyncComplete) {
            this$1.onSyncComplete();
          }
        }
      });
    }

    if ( Object3DFacade ) Text3DFacade.__proto__ = Object3DFacade;
    Text3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    Text3DFacade.prototype.constructor = Text3DFacade;

    var prototypeAccessors = { textRenderInfo: { configurable: true } };

    prototypeAccessors.textRenderInfo.get = function () {
      return this.threeObject.textRenderInfo
    };

    Text3DFacade.prototype.afterUpdate = function afterUpdate () {
      var this$1 = this;

      var textMesh = this.threeObject;
      TEXT_MESH_PROPS.forEach(function (prop) {
        textMesh[prop] = this$1[prop];
      });
      textMesh.sync();

      Object3DFacade.prototype.afterUpdate.call(this);

      if (this.text !== this._prevText) {
        // TODO mirror to DOM... this._domEl.textContent = this.text
        // Clear selection when text changes
        this.selectionStart = this.selectionEnd = -1;
        this._prevText = this.text;
      }

      this._updateSelection();
    };

    Text3DFacade.prototype._updateSelection = function _updateSelection () {
      var this$1 = this;

      var ref = this;
      var selectable = ref.selectable;
      var selectionStart = ref.selectionStart;
      var selectionEnd = ref.selectionEnd;
      var selFacade = this._selectionFacade;
      if (selectable !== this._selectable) {
        this._selectable = selectable;
        if (selectable) {
          selFacade = this._selectionFacade = new SelectionManagerFacade(this, function (start, end) {
            this$1.selectionStart = start;
            this$1.selectionEnd = end;
            this$1._updateSelection();
            this$1.requestRender();
          });
        } else {
          if (selFacade) {
            selFacade.destructor();
            selFacade = this._selectionFacade = null;
          }
          this.selectionStart = this.selectionEnd = -1;
        }
      }
      if (selFacade) {
        selFacade.textRenderInfo = this.threeObject.textRenderInfo;
        selFacade.selectionStart = selectionStart;
        selFacade.selectionEnd = selectionEnd;
        selFacade.curveRadius = this.curveRadius || 0;
        selFacade.clipRect = this.clipRect;
        selFacade.renderOrder = this.renderOrder;
        selFacade.afterUpdate();
      }

      /* TODO update selection in DOM...
      const {selectionStart, selectionEnd} = this
      if (selectionStart !== this._prevSelStart || selectionEnd !== this._prevSelEnd) {
        this._prevSelStart = selectionStart
        this._prevSelEnd = selectionEnd
        const sel = document.getSelection()
        sel.removeAllRanges()
        if (this.selectable && selectionStart > -1 && selectionEnd > selectionStart) {
          const range = document.createRange()
          range.setStart(this._domEl.firstChild, this.selectionStart)
          range.setEnd(this._domEl.firstChild, this.selectionEnd)
          sel.addRange(range)
        }
      }
      */
    };

    Text3DFacade.prototype.destructor = function destructor () {
      this.threeObject.dispose();
      //this._domEl.parentNode.removeChild(this._domEl)
      if (this._selectionFacade) {
        this._selectionFacade.destructor();
      }
      Object3DFacade.prototype.destructor.call(this);
    };

    Object.defineProperties( Text3DFacade.prototype, prototypeAccessors );

    return Text3DFacade;
  }(troika3d.Object3DFacade));

  Object.defineProperty(exports, 'GlyphsGeometry', {
    enumerable: true,
    get: function () {
      return troikaThreeText.GlyphsGeometry;
    }
  });
  Object.defineProperty(exports, 'TextMesh', {
    enumerable: true,
    get: function () {
      return troikaThreeText.Text;
    }
  });
  Object.defineProperty(exports, 'configureTextBuilder', {
    enumerable: true,
    get: function () {
      return troikaThreeText.configureTextBuilder;
    }
  });
  Object.defineProperty(exports, 'dumpSDFTextures', {
    enumerable: true,
    get: function () {
      return troikaThreeText.dumpSDFTextures;
    }
  });
  Object.defineProperty(exports, 'fontProcessorWorkerModule', {
    enumerable: true,
    get: function () {
      return troikaThreeText.fontProcessorWorkerModule;
    }
  });
  Object.defineProperty(exports, 'getCaretAtPoint', {
    enumerable: true,
    get: function () {
      return troikaThreeText.getCaretAtPoint;
    }
  });
  Object.defineProperty(exports, 'getSelectionRects', {
    enumerable: true,
    get: function () {
      return troikaThreeText.getSelectionRects;
    }
  });
  Object.defineProperty(exports, 'preloadFont', {
    enumerable: true,
    get: function () {
      return troikaThreeText.preloadFont;
    }
  });
  exports.Text3DFacade = Text3DFacade;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
