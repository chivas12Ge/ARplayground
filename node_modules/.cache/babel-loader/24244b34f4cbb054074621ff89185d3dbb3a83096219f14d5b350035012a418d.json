{"ast":null,"code":"import * as React from \"react\";\nimport * as THREE from \"three\";\nimport { useFrame, useThree } from \"@react-three/fiber\";\nimport { useXR } from \"./XR.mjs\";\nimport { useXREvent } from \"./XREvents.mjs\";\nconst tempMatrix = new THREE.Matrix4();\nfunction InteractionManager(_ref) {\n  let {\n    children\n  } = _ref;\n  const events = useThree(state => state.events);\n  const get = useThree(state => state.get);\n  const raycaster = useThree(state => state.raycaster);\n  const controllers = useXR(state => state.controllers);\n  const interactions = useXR(state => state.interactions);\n  const hoverState = useXR(state => state.hoverState);\n  const hasInteraction = useXR(state => state.hasInteraction);\n  const getInteraction = useXR(state => state.getInteraction);\n  const intersect = React.useCallback(controller => {\n    const objects = Array.from(interactions.keys());\n    tempMatrix.identity().extractRotation(controller.matrixWorld);\n    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);\n    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    return raycaster.intersectObjects(objects, true);\n  }, [interactions, raycaster]);\n  useFrame(() => {\n    if (interactions.size === 0) return;\n    for (const target of controllers) {\n      const hovering = hoverState[target.inputSource.handedness];\n      const hits = /* @__PURE__ */new Set();\n      let intersections = intersect(target.controller);\n      if (events.filter) {\n        intersections = events.filter(intersections, get());\n      } else {\n        const hit = intersections.find(i => i == null ? void 0 : i.object);\n        if (hit) intersections = [hit];\n      }\n      for (const intersection of intersections) {\n        let eventObject = intersection.object;\n        while (eventObject) {\n          if (hasInteraction(eventObject, \"onHover\") && !hovering.has(eventObject)) {\n            const handlers = getInteraction(eventObject, \"onHover\");\n            for (const handler of handlers) {\n              handler({\n                target,\n                intersection,\n                intersections\n              });\n            }\n          }\n          const moveHandlers = getInteraction(eventObject, \"onMove\");\n          moveHandlers == null ? void 0 : moveHandlers.forEach(handler => handler({\n            target,\n            intersection,\n            intersections\n          }));\n          hovering.set(eventObject, intersection);\n          hits.add(eventObject.id);\n          eventObject = eventObject.parent;\n        }\n      }\n      for (const eventObject of hovering.keys()) {\n        if (!hits.has(eventObject.id)) {\n          hovering.delete(eventObject);\n          const handlers = getInteraction(eventObject, \"onBlur\");\n          if (!handlers) continue;\n          for (const handler of handlers) {\n            handler({\n              target,\n              intersections\n            });\n          }\n        }\n      }\n    }\n  });\n  const triggerEvent = React.useCallback(interaction => e => {\n    const hovering = hoverState[e.target.inputSource.handedness];\n    const intersections = Array.from(new Set(hovering.values()));\n    interactions.forEach((handlers, object) => {\n      var _a, _b, _c;\n      if (hovering.has(object)) {\n        if (!handlers[interaction]) return;\n        for (const handler of handlers[interaction]) {\n          (_a = handler.current) == null ? void 0 : _a.call(handler, {\n            target: e.target,\n            intersection: hovering.get(object),\n            intersections\n          });\n        }\n      } else {\n        if (interaction === \"onSelect\" && handlers[\"onSelectMissed\"]) {\n          for (const handler of handlers[\"onSelectMissed\"]) {\n            (_b = handler.current) == null ? void 0 : _b.call(handler, {\n              target: e.target,\n              intersections\n            });\n          }\n        } else if (interaction === \"onSqueeze\" && handlers[\"onSqueezeMissed\"]) {\n          for (const handler of handlers[\"onSqueezeMissed\"]) {\n            (_c = handler.current) == null ? void 0 : _c.call(handler, {\n              target: e.target,\n              intersections\n            });\n          }\n        }\n      }\n    });\n  }, [hoverState, interactions]);\n  useXREvent(\"select\", triggerEvent(\"onSelect\"));\n  useXREvent(\"selectstart\", triggerEvent(\"onSelectStart\"));\n  useXREvent(\"selectend\", triggerEvent(\"onSelectEnd\"));\n  useXREvent(\"squeeze\", triggerEvent(\"onSqueeze\"));\n  useXREvent(\"squeezeend\", triggerEvent(\"onSqueezeEnd\"));\n  useXREvent(\"squeezestart\", triggerEvent(\"onSqueezeStart\"));\n  return /* @__PURE__ */React.createElement(React.Fragment, null, children);\n}\nfunction useInteraction(ref, type, handler) {\n  const addInteraction = useXR(state => state.addInteraction);\n  const removeInteraction = useXR(state => state.removeInteraction);\n  const handlerRef = React.useRef(handler != null ? handler : null);\n  React.useEffect(() => void (handlerRef.current = handler != null ? handler : null), [handler]);\n  React.useEffect(() => {\n    const target = ref.current;\n    if (!target || !handlerRef.current) return;\n    addInteraction(target, type, handlerRef);\n    return () => removeInteraction(target, type, handlerRef);\n  }, [ref, type, addInteraction, removeInteraction]);\n}\nconst Interactive = React.forwardRef(function Interactive2(_ref2, passedRef) {\n  let {\n    onHover,\n    onBlur,\n    onSelectStart,\n    onSelectEnd,\n    onSelectMissed,\n    onSelect,\n    onSqueezeStart,\n    onSqueezeEnd,\n    onSqueezeMissed,\n    onSqueeze,\n    onMove,\n    children\n  } = _ref2;\n  const ref = React.useRef(null);\n  React.useImperativeHandle(passedRef, () => ref.current);\n  useInteraction(ref, \"onHover\", onHover);\n  useInteraction(ref, \"onBlur\", onBlur);\n  useInteraction(ref, \"onSelectStart\", onSelectStart);\n  useInteraction(ref, \"onSelectEnd\", onSelectEnd);\n  useInteraction(ref, \"onSelectMissed\", onSelectMissed);\n  useInteraction(ref, \"onSelect\", onSelect);\n  useInteraction(ref, \"onSqueezeStart\", onSqueezeStart);\n  useInteraction(ref, \"onSqueezeEnd\", onSqueezeEnd);\n  useInteraction(ref, \"onSqueezeMissed\", onSqueezeMissed);\n  useInteraction(ref, \"onSqueeze\", onSqueeze);\n  useInteraction(ref, \"onMove\", onMove);\n  return /* @__PURE__ */React.createElement(\"group\", {\n    ref\n  }, children);\n});\nconst RayGrab = React.forwardRef(function RayGrab2(_ref3, forwardedRef) {\n  let {\n    onSelectStart,\n    onSelectEnd,\n    children,\n    ...rest\n  } = _ref3;\n  const grabbingController = React.useRef();\n  const groupRef = React.useRef(null);\n  const previousTransform = React.useMemo(() => new THREE.Matrix4(), []);\n  React.useImperativeHandle(forwardedRef, () => groupRef.current);\n  useFrame(() => {\n    const controller = grabbingController.current;\n    const group = groupRef.current;\n    if (!controller) return;\n    group.applyMatrix4(previousTransform);\n    group.applyMatrix4(controller.matrixWorld);\n    group.updateMatrixWorld();\n    previousTransform.copy(controller.matrixWorld).invert();\n  });\n  return /* @__PURE__ */React.createElement(Interactive, {\n    ref: groupRef,\n    onSelectStart: e => {\n      grabbingController.current = e.target.controller;\n      previousTransform.copy(e.target.controller.matrixWorld).invert();\n      onSelectStart == null ? void 0 : onSelectStart(e);\n    },\n    onSelectEnd: e => {\n      if (e.target.controller === grabbingController.current) {\n        grabbingController.current = void 0;\n      }\n      onSelectEnd == null ? void 0 : onSelectEnd(e);\n    },\n    ...rest\n  }, children);\n});\nfunction useHitTest(hitTestCallback) {\n  const session = useXR(state => state.session);\n  const hitTestSource = React.useRef();\n  const hitMatrix = React.useMemo(() => new THREE.Matrix4(), []);\n  React.useEffect(() => {\n    if (!session) return void (hitTestSource.current = void 0);\n    session.requestReferenceSpace(\"viewer\").then(async referenceSpace => {\n      var _a;\n      hitTestSource.current = await ((_a = session == null ? void 0 : session.requestHitTestSource) == null ? void 0 : _a.call(session, {\n        space: referenceSpace\n      }));\n    });\n  }, [session]);\n  useFrame((state, _, frame) => {\n    if (!frame || !hitTestSource.current) return;\n    const [hit] = frame.getHitTestResults(hitTestSource.current);\n    if (hit) {\n      const referenceSpace = state.gl.xr.getReferenceSpace();\n      const pose = hit.getPose(referenceSpace);\n      if (pose) {\n        hitMatrix.fromArray(pose.transform.matrix);\n        hitTestCallback(hitMatrix, hit);\n      }\n    }\n  });\n}\nexport { InteractionManager, Interactive, RayGrab, useHitTest, useInteraction };","map":{"version":3,"names":["tempMatrix","THREE","Matrix4","InteractionManager","_ref","children","events","useThree","state","get","raycaster","controllers","useXR","interactions","hoverState","hasInteraction","getInteraction","intersect","React","useCallback","controller","objects","Array","from","keys","identity","extractRotation","matrixWorld","ray","origin","setFromMatrixPosition","direction","set","applyMatrix4","intersectObjects","useFrame","size","target","hovering","inputSource","handedness","hits","Set","intersections","filter","hit","find","i","object","intersection","eventObject","has","handlers","handler","moveHandlers","forEach","add","id","parent","delete","triggerEvent","interaction","e","values","_a","current","call","_b","_c","useXREvent","createElement","Fragment","useInteraction","ref","type","addInteraction","removeInteraction","handlerRef","useRef","useEffect","Interactive","forwardRef","Interactive2","_ref2","passedRef","onHover","onBlur","onSelectStart","onSelectEnd","onSelectMissed","onSelect","onSqueezeStart","onSqueezeEnd","onSqueezeMissed","onSqueeze","onMove","useImperativeHandle","RayGrab","RayGrab2","_ref3","forwardedRef","rest","grabbingController","groupRef","previousTransform","useMemo","group","updateMatrixWorld","copy","invert","useHitTest","hitTestCallback","session","hitTestSource","hitMatrix","requestReferenceSpace","then","referenceSpace","requestHitTestSource","space","_","frame","getHitTestResults","gl","xr","getReferenceSpace","pose","getPose","fromArray","transform","matrix"],"sources":["/Users/gegao/Desktop/ardemo/node_modules/@react-three/xr/src/Interactions.tsx"],"sourcesContent":["import * as React from 'react'\nimport * as THREE from 'three'\nimport { useThree, useFrame } from '@react-three/fiber'\nimport { useXR } from './XR'\nimport { XRController } from './XRController'\nimport { useXREvent, XREvent, XRControllerEvent } from './XREvents'\n\nexport interface XRInteractionEvent {\n  intersection?: THREE.Intersection\n  intersections: THREE.Intersection[]\n  target: XRController\n}\n\nexport type XRInteractionType =\n  | 'onHover'\n  | 'onBlur'\n  | 'onSelect'\n  | 'onSelectEnd'\n  | 'onSelectStart'\n  | 'onSelectMissed'\n  | 'onSqueeze'\n  | 'onSqueezeEnd'\n  | 'onSqueezeStart'\n  | 'onSqueezeMissed'\n  | 'onMove'\n\nexport type XRInteractionHandler = (event: XRInteractionEvent) => void\n\nconst tempMatrix = new THREE.Matrix4()\n\nexport function InteractionManager({ children }: { children: React.ReactNode }) {\n  const events = useThree((state) => state.events)\n  const get = useThree((state) => state.get)\n  const raycaster = useThree((state) => state.raycaster)\n  const controllers = useXR((state) => state.controllers)\n  const interactions = useXR((state) => state.interactions)\n  const hoverState = useXR((state) => state.hoverState)\n  const hasInteraction = useXR((state) => state.hasInteraction)\n  const getInteraction = useXR((state) => state.getInteraction)\n\n  const intersect = React.useCallback(\n    (controller: THREE.Object3D) => {\n      const objects = Array.from(interactions.keys())\n      tempMatrix.identity().extractRotation(controller.matrixWorld)\n      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld)\n      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix)\n\n      return raycaster.intersectObjects(objects, true)\n    },\n    [interactions, raycaster]\n  )\n\n  // Trigger hover and blur events\n  useFrame(() => {\n    if (interactions.size === 0) return\n\n    for (const target of controllers) {\n      const hovering = hoverState[target.inputSource.handedness]\n      const hits = new Set()\n      let intersections = intersect(target.controller)\n\n      if (events.filter) {\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order\n        intersections = events.filter(intersections, get())\n      } else {\n        // Otherwise, filter to first hit\n        const hit = intersections.find((i) => i?.object)\n        if (hit) intersections = [hit]\n      }\n\n      for (const intersection of intersections) {\n        let eventObject: THREE.Object3D | null = intersection.object\n\n        while (eventObject) {\n          if (hasInteraction(eventObject, 'onHover') && !hovering.has(eventObject)) {\n            const handlers = getInteraction(eventObject, 'onHover')!\n            for (const handler of handlers) {\n              handler({ target, intersection, intersections })\n            }\n          }\n\n          const moveHandlers = getInteraction(eventObject, 'onMove')\n          moveHandlers?.forEach((handler) => handler({ target, intersection, intersections }))\n\n          hovering.set(eventObject, intersection)\n          hits.add(eventObject.id)\n          eventObject = eventObject.parent\n        }\n      }\n\n      // Trigger blur on all the object that were hovered in the previous frame\n      // but missed in this one\n      for (const eventObject of hovering.keys()) {\n        if (!hits.has(eventObject.id)) {\n          hovering.delete(eventObject)\n\n          const handlers = getInteraction(eventObject, 'onBlur')\n          if (!handlers) continue\n\n          for (const handler of handlers) {\n            handler({ target, intersections })\n          }\n        }\n      }\n    }\n  })\n\n  const triggerEvent = React.useCallback(\n    (interaction: XRInteractionType) => (e: XREvent<XRControllerEvent>) => {\n      const hovering = hoverState[e.target.inputSource.handedness]\n      const intersections = Array.from(new Set(hovering.values()))\n\n      interactions.forEach((handlers, object) => {\n        if (hovering.has(object)) {\n          if (!handlers[interaction]) return\n\n          for (const handler of handlers[interaction]) {\n            handler.current?.({ target: e.target, intersection: hovering.get(object), intersections })\n          }\n        } else {\n          if (interaction === 'onSelect' && handlers['onSelectMissed']) {\n            for (const handler of handlers['onSelectMissed']) {\n              handler.current?.({ target: e.target, intersections })\n            }\n          } else if (interaction === 'onSqueeze' && handlers['onSqueezeMissed']) {\n            for (const handler of handlers['onSqueezeMissed']) {\n              handler.current?.({ target: e.target, intersections })\n            }\n          }\n        }\n      })\n    },\n    [hoverState, interactions]\n  )\n\n  useXREvent('select', triggerEvent('onSelect'))\n  useXREvent('selectstart', triggerEvent('onSelectStart'))\n  useXREvent('selectend', triggerEvent('onSelectEnd'))\n  useXREvent('squeeze', triggerEvent('onSqueeze'))\n  useXREvent('squeezeend', triggerEvent('onSqueezeEnd'))\n  useXREvent('squeezestart', triggerEvent('onSqueezeStart'))\n\n  return <>{children}</>\n}\n\nexport function useInteraction(ref: React.RefObject<THREE.Object3D>, type: XRInteractionType, handler?: XRInteractionHandler) {\n  const addInteraction = useXR((state) => state.addInteraction)\n  const removeInteraction = useXR((state) => state.removeInteraction)\n  const handlerRef = React.useRef<XRInteractionHandler | null>(handler ?? null)\n  React.useEffect(() => void (handlerRef.current = handler ?? null), [handler])\n\n  React.useEffect(() => {\n    const target = ref.current\n    if (!target || !handlerRef.current) return\n\n    addInteraction(target, type, handlerRef)\n\n    return () => removeInteraction(target, type, handlerRef)\n  }, [ref, type, addInteraction, removeInteraction])\n}\n\nexport interface InteractiveProps {\n  onHover?: XRInteractionHandler\n  onBlur?: XRInteractionHandler\n  onSelectStart?: XRInteractionHandler\n  onSelectEnd?: XRInteractionHandler\n  onSelectMissed?: XRInteractionHandler\n  onSelect?: XRInteractionHandler\n  onSqueezeStart?: XRInteractionHandler\n  onSqueezeEnd?: XRInteractionHandler\n  onSqueezeMissed?: XRInteractionHandler\n  onSqueeze?: XRInteractionHandler\n  onMove?: XRInteractionHandler\n  children: React.ReactNode\n}\nexport const Interactive = React.forwardRef<THREE.Group, InteractiveProps>(function Interactive(\n  {\n    onHover,\n    onBlur,\n    onSelectStart,\n    onSelectEnd,\n    onSelectMissed,\n    onSelect,\n    onSqueezeStart,\n    onSqueezeEnd,\n    onSqueezeMissed,\n    onSqueeze,\n    onMove,\n    children\n  }: InteractiveProps,\n  passedRef\n) {\n  const ref = React.useRef<THREE.Group>(null!)\n  React.useImperativeHandle(passedRef, () => ref.current)\n\n  useInteraction(ref, 'onHover', onHover)\n  useInteraction(ref, 'onBlur', onBlur)\n  useInteraction(ref, 'onSelectStart', onSelectStart)\n  useInteraction(ref, 'onSelectEnd', onSelectEnd)\n  useInteraction(ref, 'onSelectMissed', onSelectMissed)\n  useInteraction(ref, 'onSelect', onSelect)\n  useInteraction(ref, 'onSqueezeStart', onSqueezeStart)\n  useInteraction(ref, 'onSqueezeEnd', onSqueezeEnd)\n  useInteraction(ref, 'onSqueezeMissed', onSqueezeMissed)\n  useInteraction(ref, 'onSqueeze', onSqueeze)\n  useInteraction(ref, 'onMove', onMove)\n\n  return <group ref={ref}>{children}</group>\n})\n\nexport interface RayGrabProps extends InteractiveProps {}\nexport const RayGrab = React.forwardRef<THREE.Group, RayGrabProps>(function RayGrab(\n  { onSelectStart, onSelectEnd, children, ...rest },\n  forwardedRef\n) {\n  const grabbingController = React.useRef<THREE.Object3D>()\n  const groupRef = React.useRef<THREE.Group>(null!)\n  const previousTransform = React.useMemo(() => new THREE.Matrix4(), [])\n  React.useImperativeHandle(forwardedRef, () => groupRef.current)\n\n  useFrame(() => {\n    const controller = grabbingController.current\n    const group = groupRef.current\n    if (!controller) return\n\n    group.applyMatrix4(previousTransform)\n    group.applyMatrix4(controller.matrixWorld)\n    group.updateMatrixWorld()\n\n    previousTransform.copy(controller.matrixWorld).invert()\n  })\n\n  return (\n    <Interactive\n      ref={groupRef}\n      onSelectStart={(e) => {\n        grabbingController.current = e.target.controller\n        previousTransform.copy(e.target.controller.matrixWorld).invert()\n        onSelectStart?.(e)\n      }}\n      onSelectEnd={(e) => {\n        if (e.target.controller === grabbingController.current) {\n          grabbingController.current = undefined\n        }\n        onSelectEnd?.(e)\n      }}\n      {...rest}\n    >\n      {children}\n    </Interactive>\n  )\n})\n\nexport type HitTestCallback = (hitMatrix: THREE.Matrix4, hit: XRHitTestResult) => void\n\nexport function useHitTest(hitTestCallback: HitTestCallback) {\n  const session = useXR((state) => state.session)\n  const hitTestSource = React.useRef<XRHitTestSource | undefined>()\n  const hitMatrix = React.useMemo(() => new THREE.Matrix4(), [])\n\n  React.useEffect(() => {\n    if (!session) return void (hitTestSource.current = undefined)\n\n    session.requestReferenceSpace('viewer').then(async (referenceSpace) => {\n      hitTestSource.current = await session?.requestHitTestSource?.({ space: referenceSpace })\n    })\n  }, [session])\n\n  useFrame((state, _, frame: XRFrame) => {\n    if (!frame || !hitTestSource.current) return\n\n    const [hit] = frame.getHitTestResults(hitTestSource.current)\n    if (hit) {\n      const referenceSpace = state.gl.xr.getReferenceSpace()!\n      const pose = hit.getPose(referenceSpace)\n\n      if (pose) {\n        hitMatrix.fromArray(pose.transform.matrix)\n        hitTestCallback(hitMatrix, hit)\n      }\n    }\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}