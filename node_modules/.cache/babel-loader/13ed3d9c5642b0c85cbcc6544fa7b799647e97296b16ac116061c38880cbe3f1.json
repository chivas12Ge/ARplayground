{"ast":null,"code":"import { BoxGeometry, Matrix4, Mesh, MeshBasicMaterial, Object3D } from 'three';\nclass XRPlanes extends Object3D {\n  constructor(renderer) {\n    super();\n    const matrix = new Matrix4();\n    const currentPlanes = new Map();\n    const xr = renderer.xr;\n    xr.addEventListener('planesdetected', event => {\n      const frame = event.data;\n      const planes = frame.detectedPlanes;\n      const referenceSpace = xr.getReferenceSpace();\n      let planeschanged = false;\n      for (const [plane, mesh] of currentPlanes) {\n        if (planes.has(plane) === false) {\n          mesh.geometry.dispose();\n          mesh.material.dispose();\n          this.remove(mesh);\n          currentPlanes.delete(plane);\n          planeschanged = true;\n        }\n      }\n      for (const plane of planes) {\n        if (currentPlanes.has(plane) === false) {\n          const pose = frame.getPose(plane.planeSpace, referenceSpace);\n          matrix.fromArray(pose.transform.matrix);\n          const polygon = plane.polygon;\n          let minX = Number.MAX_SAFE_INTEGER;\n          let maxX = Number.MIN_SAFE_INTEGER;\n          let minZ = Number.MAX_SAFE_INTEGER;\n          let maxZ = Number.MIN_SAFE_INTEGER;\n          for (const point of polygon) {\n            minX = Math.min(minX, point.x);\n            maxX = Math.max(maxX, point.x);\n            minZ = Math.min(minZ, point.z);\n            maxZ = Math.max(maxZ, point.z);\n          }\n          const width = maxX - minX;\n          const height = maxZ - minZ;\n          const geometry = new BoxGeometry(width, 0.01, height);\n          const material = new MeshBasicMaterial({\n            color: 0xffffff * Math.random()\n          });\n          const mesh = new Mesh(geometry, material);\n          mesh.position.setFromMatrixPosition(matrix);\n          mesh.quaternion.setFromRotationMatrix(matrix);\n          this.add(mesh);\n          currentPlanes.set(plane, mesh);\n          planeschanged = true;\n        }\n      }\n      if (planeschanged) {\n        this.dispatchEvent({\n          type: 'planeschanged'\n        });\n      }\n    });\n  }\n}\nexport { XRPlanes };","map":{"version":3,"names":["BoxGeometry","Matrix4","Mesh","MeshBasicMaterial","Object3D","XRPlanes","constructor","renderer","matrix","currentPlanes","Map","xr","addEventListener","event","frame","data","planes","detectedPlanes","referenceSpace","getReferenceSpace","planeschanged","plane","mesh","has","geometry","dispose","material","remove","delete","pose","getPose","planeSpace","fromArray","transform","polygon","minX","Number","MAX_SAFE_INTEGER","maxX","MIN_SAFE_INTEGER","minZ","maxZ","point","Math","min","x","max","z","width","height","color","random","position","setFromMatrixPosition","quaternion","setFromRotationMatrix","add","set","dispatchEvent","type"],"sources":["/Users/gegao/node_modules/three/examples/jsm/webxr/XRPlanes.js"],"sourcesContent":["import {\n\tBoxGeometry,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D\n} from 'three';\n\nclass XRPlanes extends Object3D {\n\n\tconstructor( renderer ) {\n\n\t\tsuper();\n\n\t\tconst matrix = new Matrix4();\n\n\t\tconst currentPlanes = new Map();\n\n\t\tconst xr = renderer.xr;\n\n\t\txr.addEventListener( 'planesdetected', event => {\n\n\t\t\tconst frame = event.data;\n\t\t\tconst planes = frame.detectedPlanes;\n\n\t\t\tconst referenceSpace = xr.getReferenceSpace();\n\n\t\t\tlet planeschanged = false;\n\n\t\t\tfor ( const [ plane, mesh ] of currentPlanes ) {\n\n\t\t\t\tif ( planes.has( plane ) === false ) {\n\n\t\t\t\t\tmesh.geometry.dispose();\n\t\t\t\t\tmesh.material.dispose();\n\t\t\t\t\tthis.remove( mesh );\n\n\t\t\t\t\tcurrentPlanes.delete( plane );\n\n\t\t\t\t\tplaneschanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const plane of planes ) {\n\n\t\t\t\tif ( currentPlanes.has( plane ) === false ) {\n\n\t\t\t\t\tconst pose = frame.getPose( plane.planeSpace, referenceSpace );\n\t\t\t\t\tmatrix.fromArray( pose.transform.matrix );\n\n\t\t\t\t\tconst polygon = plane.polygon;\n\n\t\t\t\t\tlet minX = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tlet maxX = Number.MIN_SAFE_INTEGER;\n\t\t\t\t\tlet minZ = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tlet maxZ = Number.MIN_SAFE_INTEGER;\n\n\t\t\t\t\tfor ( const point of polygon ) {\n\n\t\t\t\t\t\tminX = Math.min( minX, point.x );\n\t\t\t\t\t\tmaxX = Math.max( maxX, point.x );\n\t\t\t\t\t\tminZ = Math.min( minZ, point.z );\n\t\t\t\t\t\tmaxZ = Math.max( maxZ, point.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst width = maxX - minX;\n\t\t\t\t\tconst height = maxZ - minZ;\n\n\t\t\t\t\tconst geometry = new BoxGeometry( width, 0.01, height );\n\t\t\t\t\tconst material = new MeshBasicMaterial( { color: 0xffffff * Math.random() } );\n\n\t\t\t\t\tconst mesh = new Mesh( geometry, material );\n\t\t\t\t\tmesh.position.setFromMatrixPosition( matrix );\n\t\t\t\t\tmesh.quaternion.setFromRotationMatrix( matrix );\n\t\t\t\t\tthis.add( mesh );\n\n\t\t\t\t\tcurrentPlanes.set( plane, mesh );\n\n\t\t\t\t\tplaneschanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( planeschanged ) {\n\n\t\t\t\tthis.dispatchEvent( { type: 'planeschanged' } );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nexport { XRPlanes };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}